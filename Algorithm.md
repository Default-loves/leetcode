
### 尾递归
递归调用位于函数体最后一条语句，并且返回值不是表达式的一部分，在编译的时候，会优化代码，复用栈帧

---
### 简单的音乐推荐系统
- 寻找相似用户，将相似用户喜爱的歌曲进行推荐
    - 适用不同的分值表示用户不同的行为，获得用户对歌曲的喜爱程度，计算两两用户的欧几里得距离，距离小的为相似用户
- 寻找相似歌曲
    - 寻找歌曲的特征值，但是歌曲的特征值比较难寻找而且容易有主观性，可以看用户对歌曲的不同行为来表征歌曲的特征

---
### 过滤垃圾短信
1. 基于黑名单的过滤器，将骚扰电话号码和邮箱加入黑名单，可以用散列表来存储，如果数据量大的话，就用位图；时间换空间的方法：将服务放置到服务器，提供接口给用户调用
2. 基于规则的过滤器
3. 基于概率统计的过滤器，其基础理论是基于朴素贝叶斯算法
    - 将内容进行分词
    - 计算概率
![image](https://github.com/Default-loves/picFromInternet/blob/master/%E5%9F%BA%E4%BA%8E%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1.png?raw=true)

---
### 基本的算法思想
#### 贪心算法
- 针对一组数据，如果我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大
- 在每次进行选择的时候，选择对当前期望值最大的的数据
- 贪心算法并不总能给出最优解

#### 分治算法
- 原问题与分解成的小问题具有相同的模式
- 原问题分解成的子问题可以独立求解，子问题之间没有相关性
- 具有分解终止条件
- 可以将子问题合并成为原问题，并且这个合并操作的复杂度不能太高

#### 回溯算法
我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免重复和遗漏，我们把问题求解的过程分成多个阶段，每个阶段都有多种选择，我们“随意”选择一条道路，当发现这条路走到尽头或者走不通(不符合期望的解)，就回退一步到上一阶段，选择另外的道路继续走。

#### 动态规划
##### 什么样的问题适合用动态规划来解决
- 多阶段决策最优解模型：解决问题的过程，需要经过多个决策阶段，每个决策阶段对应一组状态啊，然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值
- 最优子结构：我们可以通过子问题的最优解，推导出问题的最优解，换句话说就是，后面阶段的状态可以通过前面一个阶段的状态推导出来
- 重复子问题：不同的决策序列，到达某个相同的决策阶段的时候，可能会产生重复的状态(对比与分治算法，分治算法要求分割成的子问题，不能有重复子问题)
- 无后效性：第一，我们在推导后面阶段的状态时候，只关心前一个阶段的状态，而不用关心前一个阶段的状态使怎么推导出来的；第二，某阶段一旦确定，就不受之后阶段的决策影响

#### 枚举算法

### 为什么快速排序在实际中比堆排序要好
1. 对于快速排序，数据是顺序访问的，而堆排序，数据是跳着访问的，堆排序对CPU缓存不友好
2. 堆排序的数据交换次数比快速排序要多

### 使用递归树来求解递归算法的时间复杂度

### 二叉查找树相对哈希表的优势
哈希表的插入、删除、查找时间复杂度为O(1)，而二叉查找树在比较平衡的情况下，插入、删除、查找的时间复杂度为O(logn)，不过相对哈希表其优势在于：
- 哈希表中的数据是无序的，如果要输出有序的数据，那么使用二叉查找树的中序遍历在O(n)下就可以实现，哈希表则需要另外进行排序
- 哈希表扩容耗时很多，当遇到散列冲突的时候，性能不稳定，而我们可以使用二叉平衡树来使性能保持在O(logn)
- 哈希表由于哈希冲突，哈希函数的存在，其时间复杂度不一定是常量级的，也可能比二叉查找树要慢
- 哈希表的实现比较复杂，需要考虑散列函数的设计、冲突解决办法、扩容、缩容等。二叉查找树只需要关心平衡就可以了

### 维诺图
给定由平面上任意n 个基点构成的一个集合，其对应的 Voronoi图可以采用扫描线算法，在 O(nlogn)时间内、使用O(n)空间构造出来。因为Voronoi图可以归约为n个实数的排序问题，则最好时间复杂度为O(nlogn)，即sweep line算法是最优的。
定义法：O(n^ 2logn)，增量算法：O(n^2)，分治法：O(nlogn)，sweep line算法：O(nlogn)。

### Hash Algorithm
- 实现session sticky，对session id计算哈希值，对机器数目取模，得到的值就是需要请求的机器
- 数据分片，判断数据发送到哪个机器中
- 分布式存储，将数据均匀存储在集群中

### Hash Table
散列表扩容的时候，避免一次性完成，而是分成多次完成，因此存在旧的散列表和新的散列表之间的操作
> 开放寻址法
- 优点：散列表的数据都存储在数组中，能够有效利用CPU的缓存；序列化更加简单（链表法包含了指针）
- 缺点：删除数据比较麻烦；冲突的代价更高，因此装载因子的上限不能太大，比链表法会更浪费空间
- 适用场景：数据量小，装载因子小的时候
> 链表法
- 优点：内存利用率更高，装载因子可以很高（如10）
- 缺点：对CPU缓存不友好；对于小对象，由于需要另外存储指针，所以内存消耗更高
- 适用场景：大对象、大数据量的时候
- 当保存的不是单纯的数字，而是字符串的时候，需要将字符串和链表中的每个字符串一一对比，这儿容易产生瓶颈

散列表总是和链表一起使用更加高效

### SkipList
skiplist的查找、删除、增加数据的时间复杂度和红黑树一样都是O(logn)，，不过区间查询skiplist比红黑树要快，所以Resdis使用skiplist而不是红黑树
### 二分查找
数据量太小不需要使用二分查找，数据量太大的话也不适合，因为需要顺序数组，内存中不一定存在满足条件的存储空间

二分查找的数据最好是静态数据，如果有频繁的增删操作，需要维护数据的有序性，不如使用其他数据结构

### 排序算法
#### 排序算法执行效率分析考虑以下
1. 最好情况、最差情况、平均情况时间复杂度
2. 时间复杂度的系数、常数、低阶
3. 比较次数和交换（移动）次数
4. 是否是原地排序(空间复杂度是O(1))，是否是稳定排序(对于相同值的元素，排序前后其前后顺序没有变化)

#### 冒泡排序
包含了两个原子操作，比较和交换，交换平均复杂度的分析考虑有序度，最好情况下有序度为满有序度为`n*(n-1)/2`，交换次数为0，最差情况下有序度为0，交换次数为`n*(n-1)/2`，平均下来交换次数为n*(n-1)/4，比较操作比交换操作多得多，而复杂度的上限为O(n^)，所以平均下来冒泡排序的时间复杂度为O(n^2)
#### Bucket Sort
桶排序比较适合用于外部排序中
#### Count Sort
适合在数据范围不大的情况下，而且数值只能为非负数
#### Radix Sort
数据需要可以单独分割出独立的位进行比较，并且位之间有递进的关系，每一位的数据范围不能很大，要能够用O(n)进行稳定排序
#### 一个通用的、高性能的排序函数
如果数据量不大，使用归并排序，数据量超过阈值则用快速排序，当快排的长度减小到一定阈值的时候用插入排序

### 递归
#### 包含以下3点可以使用递归算法来解决
- 一个问题可以分解为多个子问题
- 这个问题和子问题的求解思路是一样的，只是数据规模不同
- 存在递归终止条件
#### 递归容易导致的问题
空间复杂度高，重复计算，堆栈溢出，函数调用累计导致时间复杂度高
#### 怎么实现递归算法
不要被绕进去，要在子问题已经解决的情况下，思考问题之间的联系，确定终止条件

### 链表
有“哨兵”的链表，能够简化操作逻辑，有哨兵节点的链表称为带头链表，没有的称为不带头链表

注意边界条件：当链表为空，当链表只有一个节点，当链表只有两个节点，头尾节点处理等

### 并查集

并查集(不相交集)是一种描述不相交集合的数据结构，即若一个问题涉及多个元素，它们可划归到不同集合，同属一个集合内的元素等价（即可用任意一个元素作为代表，比如上述的互为亲戚即互相等价），不同集合内的元素不等价。



### 数组

数组支持随机访问，根据下标随机访问数据的时间复杂度为O(1)

针对数组类型，很多高级语言都提供了容器类，如Java的ArrayList，容器类将很多数组操作的细节封装了起来，并且提供了动态扩容

什么时候使用原生的数组而不是容器类？
1. ArrayList无法存储基本类型，都是包装类型，而Autoboxing、Unboxing还是有性能消耗的，如果对于性能要求高，则用数组
2. 如果数组的大小事先已经知道了，并且操作简单，那么用数组
3. 多维数组，数组比较直观

### 时间复杂度
T(n) = O(f(n))，T(n)表示了算法的执行时间，是一个确定的值，而O表示了算法的执行时间和f(n)成正比例，而f(n)表示了每行代码的执行次数，因此时间复杂度表示了算法的执行时间随着数据规模增长的变化趋势，而f(n)中的常量、低阶、系数并不左右增长趋势，因此一般取最大量级的项

平均时间复杂度全称为加权平均时间复杂度，或者期望时间复杂度，需要考虑在不同的情况下相关代码的执行次数，并且考虑各种情况出现的概率

均摊时间复杂度，当进行一组连续操作，大部分情况下时间复杂度很低，如O(1)，而小部分情况下时间复杂度很高，如O(n)，而且这些操作之间存在前后连贯的时序关系，那么可以将操作耗时的时间平摊到其他操作中，一般均摊时间复杂度就等于最好情况时间复杂度

### 主定理(Master Theorem)
对于分治算法根据递推式计算时间复杂度

对于常数 a>0,b>1,d≥0，如果它的递推式是 T(n)=aT(n/b)+O(nd), 那么
```math
\left\{\begin{matrix}
O(n^d)& if d > \log_ba \\
O(n^d log n)&  if d=\log_ba\\
O(n^{\log_ba})& if d < \log_ba
\end{matrix}\right.
```

### 贪心算法（Greedy Algorithm）
- 依次求得局部最优解，即在当前的状态下选择最好的结果，从而得到全局最优解;
- 和动态规划不同的点在于，其不能回退，动态规划保存了历史状态的数据，在当前状态下能根据历史数据，转移到另一个分支状态;
- 在最优子结构的问题中很有效



### Some tips

![image](https://github.com/Default-loves/picFromInternet/blob/master/Algorithm.jpg?raw=true)
![image](https://github.com/Default-loves/picFromInternet/blob/master/AlgorithmBook.jpg?raw=true)